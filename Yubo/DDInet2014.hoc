load_file("nrngui.hoc")
load_file("mitral.hoc")
load_file("gc.hoc")
cvode.active(1)

Vrest = -65
dt = 1
celsius=35
tstop=500

objref nconp[10], net, netp[10], g, b, synp, nil, stim, apc
objref mt[10], gc[30], train, outfile, coeff[10], index[14],table
objref nc[450]

strdef filename
outfile = new File()

table = new Vector()

for i=0,9 {
mt[i] = new Mitral()
}

for i=0,9 {
coeff[i] = new Vector()
}

for i=0,29 {
gc[i] = new GC()
}

for i=0,13 {
index[i] = new Vector()
}


//// record voltage trace and time into vectors	
objref rect,savdatat,savdatamt,recv,tempmatrix,recvtemp,recvtemp2

recv=new List()
recvtemp2=new Vector()
tempmatrix=new Matrix()
rect = new Vector()
savdatat = new File()
savdatamt=new File()

rect.record(&t)

tempmatrix.resize(10000,10)


for i=0,9{
  recvtemp=new Vector()
  recvtemp.record(&mt[i].soma.v(0.5))
  recv.append(recvtemp)
}

///////odor sensitivity of MCs
outfile.ropen("coeff-table.txt")
for i=0,9{
for j=0,8 {
coeff[i].append(outfile.scanvar())
}
coeff[i].printf()
}
outfile.close()

////get index number from index-table.
outfile.ropen("index-table.txt")
for j=0,13 {
index[0].append(outfile.scanvar())
}
index[0].printf()
outfile.close()

cx=3

weight=.1
amp=.03
rel=0.2
inh=13
synstr=2.3
nmdafactor=0.0035
frac=1

b = new VBox()
b.intercept(1)
g = new Graph()
g.size(0,tstop,-70,0)
g.xaxis(1)
g.addvar("mt[0].soma.v(0.5)",1,1,0.7,1,2)
g.addvar("mt[1].soma.v(0.5)",2,1,0.7,0.99,2)
g.addvar("mt[2].soma.v(0.5)",3,1,0.7,0.98,2)
g.exec_menu("10% Zoom out")
xpanel("",1)
xbutton("run", "run()")
xvalue("odor","cx")
xpanel()
b.intercept(0)
b.map()

///////////NetStim: presynaptic stimulus on MC, spike train. 
for i=0, 9 {
access mt[i].soma
	distance()
	netp[i] = new NetStim(0)
      ////trigger spike (first spike), then the average input current to MC.
	netp[i].number=1
	netp[i].interval=500
	netp[i].noise=0
      /////starting time 2ms.
	netp[i].start=2
      //////connect netp(presynaptic) to mt synodor object(postsynaptic), but weight?
	nconp[i]= new NetCon(netp[i],mt[i].synodor,0.5,0,weight*1.e-3) 
}

////////////////// circuit definition  

///// gc <-> mt
w0=1 
w1=0.8
w2=0.4

nccount=0

 for i=0,2 {
   
    for k=0,9{
    
     ////right side connections of gc[k]
      for j=0,1 {
       nccount=nccount+1
       gc[k+i*10].dend[j*2+2]   nc[nccount] = new NetCon(&v(1),mt[index[0].x[k+j+3]].igp[0][(j+1)+i*2],-40,1,w1*inh*1e-3)

       nccount=nccount+1
       mt[index[0].x[k+j+3]].secden[0]  nc[nccount]= new NetCon(&v(0),gc[k+i*10].synmt[j+1],-40,1,w1*synstr*nmdafactor)

       nccount=nccount+1
       mt[index[0].x[k+j+3]].secden[0]  nc[nccount]= new NetCon(&v(0),gc[k+i*10].sampa[j+1],-40,1,w1*synstr*1e-3)

                 }

     
     /////left side connections of gc[k] 
       for j=0,1 {
       nccount=nccount+1
       gc[k+i*10].dend[j*2+6]   nc[nccount] = new NetCon(&v(1),mt[index[0].x[k+j+1]].igp[1][(j+1)+i*2],-40,1,w2*inh*1e-3)

       nccount=nccount+1
       mt[index[0].x[k+j+1]].secden[1]  nc[nccount]= new NetCon(&v(0),gc[k+i*10].synmt[j+3],-40,1,w2*synstr*nmdafactor)

       nccount=nccount+1
       mt[index[0].x[k+j+1]].secden[1]  nc[nccount]= new NetCon(&v(0),gc[k+i*10].sampa[j+3],-40,1,w2*synstr*1e-3) 

                }
        
  
              }
           }
    
    ////middle connections of gc[k]
     for i=0,1 {

      for k=0,9 {
       nccount=nccount+1
       gc[k+10*i].dend[0]   nc[nccount] = new NetCon(&v(1),mt[index[0].x[k+3]].igp[i][0],-40,1,w0*inh*1e-3)

       nccount=nccount+1
       mt[index[0].x[j+3]].secden[i]  nc[nccount]= new NetCon(&v(0),gc[k+10*i].synmt[0],-40,1,w0*synstr*nmdafactor)

       nccount=nccount+1
       mt[index[0].x[j+3]].secden[i]  nc[nccount]= new NetCon(&v(0),gc[k+10*i].sampa[0],-40,1,w0*synstr*1e-3)

                 }
              }
     /////gc[20]-gc[30] don't have middle connections, or they can all be connected with igp[0 or 1][7] of all MTs.


////////////////// end circuit definition


proc init() {
	t=0
	finitialize(Vrest)
        fcurrent()
        forall {
		v=Vrest
		if (ismembrane("nax")) {e_pas=v+(ina+ik)/g_pas
		} else {
		e_pas=v+ik/g_pas
		}
	}
	cvode.re_init()
	g.begin()
	g.plot(t)
}

proc advance() {
	fadvance()
	g.plot(t)
	g.flush()
	doNotify()
}

////// x[i], returns the value for the index i
proc run() {
	for i=0, 9 {
	nconp[i].weight=coeff[i].x[cx-3]*1.e-3
	print i, nconp[i].weight
}
	stdinit()
	continuerun(tstop)

//// open new file
	savdatamt.wopen("mt.dat")
	
	//// print titles of columns to file
	savdatamt.printf("mt\n")
	savdatamt.printf("%d\n",rect.size())
	
	//// print data to file
	
     for i=0,9{
      recvtemp2=recv.o(i)
      tempmatrix.setcol(i,recvtemp2) 
              }

     tempmatrix.fprint(savdatamt, " %g")
     savdatamt.close()
}
